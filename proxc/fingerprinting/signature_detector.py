"""
Proxy Signature Detection System
===============================

Advanced signature-based proxy detection using HTTP headers, response patterns,
error messages, and behavioral characteristics to identify proxy server types.
"""

import json
import logging
import re
import time
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Set, Tuple, Union, Any
from pathlib import Path

# Third-party imports with fallbacks
try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

# Import our core types
from . import ProxyType, FingerprintingMethod, ConfidenceLevel
from ..proxy_core.models import ProxyInfo

logger = logging.getLogger(__name__)


@dataclass
class ProxySignature:
    """Signature definition for proxy detection"""
    proxy_type: ProxyType
    method: FingerprintingMethod
    
    # Header-based signatures
    required_headers: Dict[str, str] = field(default_factory=dict)  # header -> pattern
    forbidden_headers: Set[str] = field(default_factory=set)
    header_patterns: Dict[str, str] = field(default_factory=dict)  # header -> regex
    
    # Response-based signatures
    response_patterns: List[str] = field(default_factory=list)  # Response body patterns
    status_code_patterns: List[int] = field(default_factory=list)
    
    # Error-based signatures
    error_patterns: List[str] = field(default_factory=list)  # Error message patterns
    
    # Timing-based signatures
    response_time_range: Optional[Tuple[float, float]] = None  # (min, max) in ms
    
    # Behavioral signatures
    keep_alive_behavior: Optional[bool] = None
    compression_support: Optional[bool] = None
    
    # Metadata
    confidence_weight: float = 1.0  # Weight for confidence calculation
    version_pattern: Optional[str] = None  # Pattern to extract version
    description: str = ""


@dataclass
class DetectionResult:
    """Result of proxy signature detection"""
    proxy_type: ProxyType
    method: FingerprintingMethod
    confidence: ConfidenceLevel
    confidence_score: float  # 0.0 to 1.0
    
    # Supporting evidence
    matched_signatures: List[ProxySignature] = field(default_factory=list)
    evidence: Dict[str, Any] = field(default_factory=dict)
    version: Optional[str] = None
    
    # Metadata
    detection_time: datetime = field(default_factory=datetime.utcnow)
    analysis_duration: float = 0.0


class SignatureDatabase:
    """Database of proxy signatures for detection"""
    
    def __init__(self):
        self.signatures: List[ProxySignature] = []
        self._initialize_builtin_signatures()
    
    def _initialize_builtin_signatures(self):
        """Initialize built-in proxy signatures"""
        
        # Squid proxy signatures
        self.signatures.extend([
            ProxySignature(
                proxy_type=ProxyType.SQUID,
                method=FingerprintingMethod.HEADER_ANALYSIS,
                required_headers={"via": r".*squid.*"},
                header_patterns={
                    "server": r"squid/.*",
                    "x-squid-error": r".*"
                },
                version_pattern=r"squid/(\d+\.\d+)",
                confidence_weight=0.9,
                description="Squid proxy via header detection"
            ),
            ProxySignature(
                proxy_type=ProxyType.SQUID,
                method=FingerprintingMethod.ERROR_MESSAGE,
                error_patterns=[
                    "Generated by squid",
                    "cache.squid-cache.org",
                    "Squid/.*\\.\\."
                ],
                confidence_weight=0.95,
                description="Squid proxy error page detection"
            )
        ])
        
        # TinyProxy signatures
        self.signatures.extend([
            ProxySignature(
                proxy_type=ProxyType.TINYPROXY,
                method=FingerprintingMethod.HEADER_ANALYSIS,
                header_patterns={
                    "server": r"tinyproxy.*",
                    "via": r".*tinyproxy.*"
                },
                version_pattern=r"tinyproxy/(\d+\.\d+)",
                confidence_weight=0.85,
                description="TinyProxy server header detection"
            ),
            ProxySignature(
                proxy_type=ProxyType.TINYPROXY,
                method=FingerprintingMethod.ERROR_MESSAGE,
                error_patterns=[
                    "tinyproxy.*forbid",
                    "TinyProxy Error"
                ],
                confidence_weight=0.8,
                description="TinyProxy error message detection"
            )
        ])
        
        # Apache HTTP Server as proxy
        self.signatures.extend([
            ProxySignature(
                proxy_type=ProxyType.APACHE_HTTPD,
                method=FingerprintingMethod.HEADER_ANALYSIS,
                header_patterns={
                    "server": r"Apache.*",
                    "via": r".*Apache.*"
                },
                required_headers={"server": r"Apache"},
                version_pattern=r"Apache/(\d+\.\d+\.\d+)",
                confidence_weight=0.7,  # Lower confidence as Apache is common
                description="Apache HTTP Server proxy detection"
            )
        ])
        
        # Nginx proxy signatures
        self.signatures.extend([
            ProxySignature(
                proxy_type=ProxyType.NGINX,
                method=FingerprintingMethod.HEADER_ANALYSIS,
                header_patterns={
                    "server": r"nginx.*",
                    "via": r".*nginx.*"
                },
                version_pattern=r"nginx/(\d+\.\d+)",
                confidence_weight=0.7,
                description="Nginx proxy server detection"
            )
        ])
        
        # HAProxy signatures
        self.signatures.extend([
            ProxySignature(
                proxy_type=ProxyType.HAPROXY,
                method=FingerprintingMethod.HEADER_ANALYSIS,
                header_patterns={
                    "server": r"HAProxy.*",
                    "via": r".*HAProxy.*"
                },
                version_pattern=r"HAProxy/(\d+\.\d+)",
                confidence_weight=0.85,
                description="HAProxy load balancer detection"
            )
        ])
        
        # Cloudflare signatures
        self.signatures.extend([
            ProxySignature(
                proxy_type=ProxyType.CLOUDFLARE,
                method=FingerprintingMethod.HEADER_ANALYSIS,
                required_headers={
                    "cf-ray": r".*",
                    "server": r"cloudflare"
                },
                header_patterns={
                    "cf-cache-status": r".*",
                    "cf-request-id": r".*"
                },
                confidence_weight=0.95,
                description="Cloudflare CDN/proxy detection"
            )
        ])
        
        # CloudFront signatures
        self.signatures.extend([
            ProxySignature(
                proxy_type=ProxyType.CLOUDFRONT,
                method=FingerprintingMethod.HEADER_ANALYSIS,
                required_headers={
                    "via": r".*CloudFront.*"
                },
                header_patterns={
                    "x-amz-cf-id": r".*",
                    "x-cache": r".*cloudfront.*"
                },
                confidence_weight=0.9,
                description="AWS CloudFront CDN detection"
            )
        ])
        
        # Fastly signatures
        self.signatures.extend([
            ProxySignature(
                proxy_type=ProxyType.FASTLY,
                method=FingerprintingMethod.HEADER_ANALYSIS,
                header_patterns={
                    "via": r".*fastly.*",
                    "x-served-by": r".*fastly.*",
                    "fastly-debug": r".*"
                },
                confidence_weight=0.85,
                description="Fastly CDN detection"
            )
        ])
        
        # Traefik signatures
        self.signatures.extend([
            ProxySignature(
                proxy_type=ProxyType.TRAEFIK,
                method=FingerprintingMethod.HEADER_ANALYSIS,
                header_patterns={
                    "server": r"traefik.*",
                    "x-forwarded-server": r"traefik.*"
                },
                confidence_weight=0.8,
                description="Traefik reverse proxy detection"
            )
        ])
        
        # Envoy proxy signatures
        self.signatures.extend([
            ProxySignature(
                proxy_type=ProxyType.ENVOY,
                method=FingerprintingMethod.HEADER_ANALYSIS,
                header_patterns={
                    "server": r"envoy",
                    "x-envoy-.*": r".*"
                },
                confidence_weight=0.8,
                description="Envoy proxy detection"
            )
        ])
        
        logger.info(f"Initialized {len(self.signatures)} built-in proxy signatures")
    
    def add_signature(self, signature: ProxySignature):
        """Add custom signature to database"""
        self.signatures.append(signature)
    
    def get_signatures_by_type(self, proxy_type: ProxyType) -> List[ProxySignature]:
        """Get all signatures for a specific proxy type"""
        return [sig for sig in self.signatures if sig.proxy_type == proxy_type]
    
    def get_signatures_by_method(self, method: FingerprintingMethod) -> List[ProxySignature]:
        """Get all signatures for a specific detection method"""
        return [sig for sig in self.signatures if sig.method == method]
    
    def load_custom_signatures(self, file_path: str):
        """Load custom signatures from JSON file"""
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
            
            for sig_data in data.get('signatures', []):
                signature = ProxySignature(
                    proxy_type=ProxyType(sig_data['proxy_type']),
                    method=FingerprintingMethod(sig_data['method']),
                    required_headers=sig_data.get('required_headers', {}),
                    forbidden_headers=set(sig_data.get('forbidden_headers', [])),
                    header_patterns=sig_data.get('header_patterns', {}),
                    response_patterns=sig_data.get('response_patterns', []),
                    error_patterns=sig_data.get('error_patterns', []),
                    confidence_weight=sig_data.get('confidence_weight', 1.0),
                    description=sig_data.get('description', '')
                )
                self.add_signature(signature)
            
            logger.info(f"Loaded custom signatures from {file_path}")
            
        except Exception as e:
            logger.error(f"Failed to load custom signatures: {e}")


class ProxySignatureDetector:
    """Main proxy signature detection engine"""
    
    def __init__(self, signature_db: Optional[SignatureDatabase] = None):
        self.signature_db = signature_db or SignatureDatabase()
        self.detection_cache: Dict[str, DetectionResult] = {}
    
    def detect_proxy_type(
        self,
        proxy_info: ProxyInfo,
        test_url: str = "http://httpbin.org/headers",
        timeout: int = 10
    ) -> DetectionResult:
        """Detect proxy type using signature matching"""
        
        start_time = time.time()
        
        # Check cache first
        cache_key = f"{proxy_info.ip}:{proxy_info.port}"
        if cache_key in self.detection_cache:
            cached = self.detection_cache[cache_key]
            if (datetime.utcnow() - cached.detection_time).total_seconds() < 3600:  # 1 hour cache
                return cached
        
        # Perform detection
        result = self._perform_detection(proxy_info, test_url, timeout)
        result.analysis_duration = time.time() - start_time
        
        # Cache result
        self.detection_cache[cache_key] = result
        
        return result
    
    def _perform_detection(
        self,
        proxy_info: ProxyInfo,
        test_url: str,
        timeout: int
    ) -> DetectionResult:
        """Perform actual proxy type detection"""
        
        if not HAS_REQUESTS:
            return DetectionResult(
                proxy_type=ProxyType.UNKNOWN,
                method=FingerprintingMethod.HEADER_ANALYSIS,
                confidence=ConfidenceLevel.VERY_LOW,
                confidence_score=0.0,
                evidence={'error': 'requests library not available'}
            )
        
        try:
            # Configure proxy
            proxy_url = f"http://{proxy_info.ip}:{proxy_info.port}"
            proxies = {
                'http': proxy_url,
                'https': proxy_url
            }
            
            # Make request through proxy
            response = requests.get(
                test_url,
                proxies=proxies,
                timeout=timeout,
                verify=False,
                allow_redirects=True
            )
            
            # Analyze response
            return self._analyze_response(response)
            
        except requests.exceptions.ProxyError as e:
            # Analyze proxy error for signatures
            return self._analyze_proxy_error(str(e))
        except Exception as e:
            return DetectionResult(
                proxy_type=ProxyType.UNKNOWN,
                method=FingerprintingMethod.HEADER_ANALYSIS,
                confidence=ConfidenceLevel.VERY_LOW,
                confidence_score=0.0,
                evidence={'error': str(e)}
            )
    
    def _analyze_response(self, response: requests.Response) -> DetectionResult:
        """Analyze HTTP response for proxy signatures"""
        
        matched_signatures = []
        evidence = {
            'headers': dict(response.headers),
            'status_code': response.status_code,
            'response_size': len(response.content)
        }
        
        # Check header-based signatures
        header_matches = self._check_header_signatures(response.headers)
        matched_signatures.extend(header_matches)
        
        # Check response body for error patterns
        if response.status_code >= 400:
            error_matches = self._check_error_signatures(response.text)
            matched_signatures.extend(error_matches)
        
        # Check response patterns
        response_matches = self._check_response_signatures(response.text)
        matched_signatures.extend(response_matches)
        
        # Determine best match
        if matched_signatures:
            best_match = max(matched_signatures, key=lambda s: s.confidence_weight)
            confidence_score = min(best_match.confidence_weight, 1.0)
            
            # Extract version if available
            version = self._extract_version(response.headers, best_match)
            
            return DetectionResult(
                proxy_type=best_match.proxy_type,
                method=best_match.method,
                confidence=self._score_to_confidence_level(confidence_score),
                confidence_score=confidence_score,
                matched_signatures=matched_signatures,
                evidence=evidence,
                version=version
            )
        else:
            return DetectionResult(
                proxy_type=ProxyType.UNKNOWN,
                method=FingerprintingMethod.HEADER_ANALYSIS,
                confidence=ConfidenceLevel.VERY_LOW,
                confidence_score=0.0,
                evidence=evidence
            )
    
    def _check_header_signatures(self, headers: dict) -> List[ProxySignature]:
        """Check headers against signature database"""
        matches = []
        
        header_sigs = self.signature_db.get_signatures_by_method(
            FingerprintingMethod.HEADER_ANALYSIS
        )
        
        for signature in header_sigs:
            score = 0
            total_checks = 0
            
            # Check required headers
            for header, pattern in signature.required_headers.items():
                total_checks += 1
                if header.lower() in [h.lower() for h in headers.keys()]:
                    header_value = next(
                        (v for k, v in headers.items() if k.lower() == header.lower()),
                        ""
                    )
                    if re.search(pattern, header_value, re.IGNORECASE):
                        score += 1
            
            # Check forbidden headers (negative matches)
            for header in signature.forbidden_headers:
                total_checks += 1
                if header.lower() not in [h.lower() for h in headers.keys()]:
                    score += 1
            
            # Check header patterns
            for header, pattern in signature.header_patterns.items():
                total_checks += 1
                if header.lower() in [h.lower() for h in headers.keys()]:
                    header_value = next(
                        (v for k, v in headers.items() if k.lower() == header.lower()),
                        ""
                    )
                    if re.search(pattern, header_value, re.IGNORECASE):
                        score += 1
            
            # Calculate match score
            if total_checks > 0 and score / total_checks >= 0.5:
                matches.append(signature)
        
        return matches
    
    def _check_error_signatures(self, response_text: str) -> List[ProxySignature]:
        """Check response text for error-based signatures"""
        matches = []
        
        error_sigs = self.signature_db.get_signatures_by_method(
            FingerprintingMethod.ERROR_MESSAGE
        )
        
        for signature in error_sigs:
            for pattern in signature.error_patterns:
                if re.search(pattern, response_text, re.IGNORECASE | re.MULTILINE):
                    matches.append(signature)
                    break
        
        return matches
    
    def _check_response_signatures(self, response_text: str) -> List[ProxySignature]:
        """Check response text for general response patterns"""
        matches = []
        
        for signature in self.signature_db.signatures:
            if signature.response_patterns:
                for pattern in signature.response_patterns:
                    if re.search(pattern, response_text, re.IGNORECASE | re.MULTILINE):
                        matches.append(signature)
                        break
        
        return matches
    
    def _analyze_proxy_error(self, error_message: str) -> DetectionResult:
        """Analyze proxy connection error for signatures"""
        
        # Check error message against signatures
        matched_signatures = []
        for signature in self.signature_db.signatures:
            if signature.error_patterns:
                for pattern in signature.error_patterns:
                    if re.search(pattern, error_message, re.IGNORECASE):
                        matched_signatures.append(signature)
                        break
        
        if matched_signatures:
            best_match = max(matched_signatures, key=lambda s: s.confidence_weight)
            confidence_score = min(best_match.confidence_weight * 0.8, 1.0)  # Reduce confidence for error-based detection
            
            return DetectionResult(
                proxy_type=best_match.proxy_type,
                method=FingerprintingMethod.ERROR_MESSAGE,
                confidence=self._score_to_confidence_level(confidence_score),
                confidence_score=confidence_score,
                matched_signatures=matched_signatures,
                evidence={'error_message': error_message}
            )
        else:
            return DetectionResult(
                proxy_type=ProxyType.UNKNOWN,
                method=FingerprintingMethod.ERROR_MESSAGE,
                confidence=ConfidenceLevel.VERY_LOW,
                confidence_score=0.0,
                evidence={'error_message': error_message}
            )
    
    def _extract_version(self, headers: dict, signature: ProxySignature) -> Optional[str]:
        """Extract version information from headers"""
        if not signature.version_pattern:
            return None
        
        # Check common version headers
        version_headers = ['server', 'via', 'x-powered-by']
        
        for header_name in version_headers:
            header_value = next(
                (v for k, v in headers.items() if k.lower() == header_name.lower()),
                ""
            )
            
            if header_value:
                match = re.search(signature.version_pattern, header_value, re.IGNORECASE)
                if match:
                    return match.group(1)
        
        return None
    
    def _score_to_confidence_level(self, score: float) -> ConfidenceLevel:
        """Convert confidence score to confidence level"""
        if score >= 0.9:
            return ConfidenceLevel.HIGH
        elif score >= 0.7:
            return ConfidenceLevel.MEDIUM
        elif score >= 0.5:
            return ConfidenceLevel.LOW
        else:
            return ConfidenceLevel.VERY_LOW
    
    def batch_detect(
        self,
        proxy_list: List[ProxyInfo],
        test_url: str = "http://httpbin.org/headers",
        timeout: int = 10,
        max_concurrent: int = 10
    ) -> List[Tuple[ProxyInfo, DetectionResult]]:
        """Perform batch proxy type detection"""
        results = []
        
        # Simple sequential processing for now
        # In production, would use asyncio for concurrent processing
        for proxy in proxy_list[:max_concurrent]:  # Limit for safety
            try:
                result = self.detect_proxy_type(proxy, test_url, timeout)
                results.append((proxy, result))
            except Exception as e:
                logger.error(f"Detection failed for {proxy.ip}:{proxy.port}: {e}")
                error_result = DetectionResult(
                    proxy_type=ProxyType.UNKNOWN,
                    method=FingerprintingMethod.HEADER_ANALYSIS,
                    confidence=ConfidenceLevel.VERY_LOW,
                    confidence_score=0.0,
                    evidence={'error': str(e)}
                )
                results.append((proxy, error_result))
        
        return results
    
    def get_detection_summary(self) -> Dict[str, Any]:
        """Get summary of detection results"""
        if not self.detection_cache:
            return {}
        
        type_counts = {}
        confidence_counts = {}
        
        for result in self.detection_cache.values():
            # Count proxy types
            type_name = result.proxy_type.value
            type_counts[type_name] = type_counts.get(type_name, 0) + 1
            
            # Count confidence levels
            conf_name = result.confidence.value
            confidence_counts[conf_name] = confidence_counts.get(conf_name, 0) + 1
        
        return {
            'total_detections': len(self.detection_cache),
            'proxy_types': type_counts,
            'confidence_distribution': confidence_counts,
            'average_analysis_time': sum(
                r.analysis_duration for r in self.detection_cache.values()
            ) / len(self.detection_cache)
        }