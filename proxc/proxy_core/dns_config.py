"""DNS Configuration Manager - Platform-aware DNS resolver configuration"""

import os
import logging
from pathlib import Path
from typing import List, Optional, Dict, Any
from datetime import datetime

try:
    import dns.resolver
    import dns.rdatatype
    import dns.exception
    HAS_DNSPYTHON = True
except ImportError:
    HAS_DNSPYTHON = False

from .platform_utils import (
    is_termux, is_android, get_platform_info, 
    get_dns_config_requirements, get_optimal_dns_servers,
    create_project_config_dir
)

logger = logging.getLogger(__name__)


class DNSConfigManager:
    """Manages DNS configuration for cross-platform compatibility"""
    
    def __init__(self, config_dir: Optional[Path] = None):
        self.config_dir = config_dir or create_project_config_dir()
        self.resolv_conf_path = self.config_dir / 'resolv.conf'
        self.blacklist_config_path = self.config_dir / 'dns_blacklists.json'
        
        self.platform_info = get_platform_info()
        self.needs_local_config, self.config_reason = get_dns_config_requirements()
        
        self._resolver = None
        self._initialized = False
        
        # Initialize DNS configuration
        self._initialize()
    
    def _initialize(self):
        """Initialize DNS configuration based on platform"""
        try:
            if self.needs_local_config:
                self._create_local_dns_config()
                self._setup_custom_resolver()
            else:
                self._setup_system_resolver()
            
            self._initialized = True
            logger.info(f"DNS resolver initialized: {self.config_reason}")
            
        except Exception as e:
            logger.error(f"DNS initialization failed: {e}")
            self._setup_fallback_resolver()
    
    def _create_local_dns_config(self):
        """Create local resolv.conf for Termux/Android environments"""
        dns_servers = get_optimal_dns_servers()
        
        config_content = [
            f"# Generated by ProxyHunter DNS Config Manager",
            f"# Created: {datetime.now().isoformat()}",
            f"# Platform: {self.platform_info['system']} ({'Termux' if is_termux() else 'Android' if is_android() else 'Other'})",
            "",
        ]
        
        # Add nameservers
        for server in dns_servers:
            config_content.append(f"nameserver {server}")
        
        config_content.extend([
            "",
            "# Options for faster resolution",
            "options timeout:3",
            "options attempts:2",
            "options rotate",
            "options edns0",
        ])
        
        # Write configuration file
        try:
            with open(self.resolv_conf_path, 'w') as f:
                f.write('\n'.join(config_content))
            
            logger.info(f"Local DNS config created: {self.resolv_conf_path}")
            logger.debug(f"DNS servers: {', '.join(dns_servers)}")
            
        except Exception as e:
            logger.error(f"Failed to create local DNS config: {e}")
            raise
    
    def _setup_custom_resolver(self):
        """Setup DNS resolver with custom configuration"""
        if not HAS_DNSPYTHON:
            logger.warning("dnspython not available, DNS blacklist checks disabled")
            return
        
        try:
            self._resolver = dns.resolver.Resolver(configure=False)
            
            # Set nameservers from our config
            dns_servers = get_optimal_dns_servers()
            self._resolver.nameservers = dns_servers
            
            # Configure timeouts and behavior
            self._resolver.timeout = 3.0
            self._resolver.lifetime = 6.0  # Total time for all attempts
            
            logger.debug(f"Custom DNS resolver configured with servers: {dns_servers}")
            
        except Exception as e:
            logger.error(f"Failed to setup custom resolver: {e}")
            self._setup_fallback_resolver()
    
    def _setup_system_resolver(self):
        """Setup standard system DNS resolver"""
        if not HAS_DNSPYTHON:
            logger.warning("dnspython not available, DNS blacklist checks disabled")
            return
        
        try:
            # Use default system resolver
            self._resolver = dns.resolver.get_default_resolver()
            logger.debug("System DNS resolver configured")
            
        except Exception as e:
            logger.error(f"Failed to setup system resolver: {e}")
            self._setup_fallback_resolver()
    
    def _setup_fallback_resolver(self):
        """Setup fallback resolver as last resort"""
        if not HAS_DNSPYTHON:
            self._resolver = None
            return
        
        try:
            # Create minimal resolver with public DNS
            self._resolver = dns.resolver.Resolver(configure=False)
            self._resolver.nameservers = ['1.1.1.1', '8.8.8.8']
            self._resolver.timeout = 5.0
            self._resolver.lifetime = 10.0
            
            logger.warning("Using fallback DNS resolver (1.1.1.1, 8.8.8.8)")
            
        except Exception as e:
            logger.error(f"Even fallback resolver failed: {e}")
            self._resolver = None
    
    def resolve_dns(self, query: str, record_type: str = 'A') -> Optional[List[str]]:
        """Resolve DNS query using configured resolver
        
        Args:
            query: DNS query (e.g., domain name)
            record_type: DNS record type ('A', 'AAAA', 'TXT', etc.)
            
        Returns:
            List of resolved records or None if resolution fails
        """
        if not self._resolver or not HAS_DNSPYTHON:
            return None
        
        try:
            # Convert record type string to dns.rdatatype
            if hasattr(dns.rdatatype, record_type.upper()):
                rdtype = getattr(dns.rdatatype, record_type.upper())
            else:
                logger.warning(f"Unknown DNS record type: {record_type}")
                return None
            
            # Perform DNS resolution
            answers = self._resolver.resolve(query, rdtype)
            results = [str(answer) for answer in answers]
            
            logger.debug(f"DNS resolution: {query} ({record_type}) -> {results}")
            return results
            
        except dns.resolver.NXDOMAIN:
            # Domain doesn't exist - this is expected for blacklist checks
            logger.debug(f"DNS NXDOMAIN: {query}")
            return []
        except dns.resolver.NoAnswer:
            # No records of this type - also expected
            logger.debug(f"DNS NoAnswer: {query} ({record_type})")
            return []
        except dns.resolver.Timeout:
            logger.warning(f"DNS timeout: {query}")
            return None
        except Exception as e:
            logger.error(f"DNS resolution failed for {query}: {e}")
            return None
    
    def check_blacklist(self, ip_address: str, blacklist_host: str) -> bool:
        """Check if IP is listed in DNS blacklist
        
        Args:
            ip_address: IP address to check
            blacklist_host: Blacklist hostname (e.g., 'zen.spamhaus.org')
            
        Returns:
            True if IP is blacklisted, False otherwise
        """
        if not self._resolver:
            logger.debug(f"DNS resolver not available, skipping blacklist check")
            return False
        
        try:
            # Reverse IP address for DNS blacklist query
            ip_parts = ip_address.split('.')
            if len(ip_parts) != 4:
                logger.warning(f"Invalid IPv4 address for blacklist check: {ip_address}")
                return False
            
            reversed_ip = '.'.join(reversed(ip_parts))
            query_host = f"{reversed_ip}.{blacklist_host}"
            
            # Perform blacklist check
            result = self.resolve_dns(query_host, 'A')
            
            if result is None:
                # DNS resolution failed
                return False
            elif len(result) > 0:
                # IP is listed (got A record response)
                logger.debug(f"Blacklist hit: {ip_address} listed in {blacklist_host}")
                return True
            else:
                # IP is not listed (NXDOMAIN or NoAnswer)
                return False
                
        except Exception as e:
            logger.error(f"Blacklist check failed for {ip_address} on {blacklist_host}: {e}")
            return False
    
    def get_blacklist_services(self) -> Dict[str, str]:
        """Get available DNS blacklist services
        
        Returns:
            Dict mapping service names to blacklist hostnames
        """
        return {
            'spamhaus_zen': 'zen.spamhaus.org',
            'spamhaus_pbl': 'pbl.spamhaus.org',
            'barracuda': 'b.barracudacentral.org',
            'sorbs': 'dnsbl.sorbs.net',
            'abuse_ch': 'drone.abuse.ch',
            'malwaredomains': 'malwaredomains.lehigh.edu',
            'uribl_multi': 'multi.uribl.com',
            'surbl_multi': 'multi.surbl.org'
        }
    
    def is_available(self) -> bool:
        """Check if DNS resolver is available and working"""
        if not self._initialized or not self._resolver:
            return False
        
        # Test with a simple query
        try:
            result = self.resolve_dns('google.com', 'A')
            return result is not None and len(result) > 0
        except:
            return False
    
    def get_status(self) -> Dict[str, Any]:
        """Get DNS configuration status"""
        return {
            'initialized': self._initialized,
            'available': self.is_available(),
            'needs_local_config': self.needs_local_config,
            'config_reason': self.config_reason,
            'resolver_type': 'custom' if self.needs_local_config else 'system',
            'local_config_path': str(self.resolv_conf_path) if self.needs_local_config else None,
            'has_dnspython': HAS_DNSPYTHON,
            'platform_info': self.platform_info
        }


# Global DNS configuration manager instance
_dns_manager = None


def get_dns_manager() -> DNSConfigManager:
    """Get global DNS configuration manager instance"""
    global _dns_manager
    if _dns_manager is None:
        _dns_manager = DNSConfigManager()
    return _dns_manager


def initialize_dns_config() -> DNSConfigManager:
    """Initialize DNS configuration for the application"""
    dns_manager = get_dns_manager()
    
    if dns_manager.is_available():
        logger.info(f"DNS configuration ready: {dns_manager.config_reason}")
    else:
        logger.warning("DNS configuration failed, blacklist checks may not work")
    
    return dns_manager


if __name__ == '__main__':
    # Test DNS configuration
    print("DNS Configuration Test")
    print("=" * 30)
    
    dns_manager = DNSConfigManager()
    status = dns_manager.get_status()
    
    for key, value in status.items():
        if key != 'platform_info':  # Skip detailed platform info
            print(f"{key}: {value}")
    
    print("\nDNS Resolution Test:")
    if dns_manager.is_available():
        test_result = dns_manager.resolve_dns('google.com', 'A')
        print(f"google.com A: {test_result}")
        
        # Test blacklist check
        print(f"\nBlacklist Test (should be False):")
        bl_result = dns_manager.check_blacklist('8.8.8.8', 'zen.spamhaus.org')
        print(f"8.8.8.8 in zen.spamhaus.org: {bl_result}")
    else:
        print("DNS resolver not available")